# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

extends c

snippet bellmanford "ベルマンフォード法"
template<typename T>
class bellmanford {
public:
	struct edge {
		int from, to;
		T cost;
	};
	int V;
	T inf;
	vector<T> d;
	vector<edge> es;
	bellmanford(int n) : V(n), inf(numeric_limits<T>::max()/2), d(n, inf){}
	void add_edge(int from, int to, T cost){
		es.push_back((edge){from,to,cost});
	}
	bool solve(int s) {
		d[s] = 0;
		T cnt;
		for (cnt = 0; cnt < V; cnt++) {
			bool update = false;
			for (auto&& e : es) {
				if (d[e.from] < inf and d[e.to]  > d[e.from] + e.cost) {
					d[e.to] = d[e.from] + e.cost;
					update = true;
				}
			}
			if (!update) {
				break;
			}
		}
		return (cnt == V);
	}
};
endsnippet

snippet max_flow "最大流"
int inf = INT32_MAX;
struct max_flow {
	struct edge { int to, cap, rev; };
	int V;
	vector<vector<edge>> G;
	vector<int> itr, level;

	max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }

	void add_edge(int from, int to, int cap) {
		G[from].push_back((edge) {to, cap, (int) G[to].size()});
		G[to].push_back((edge) {from, 0, (int) G[from].size()-1});
	}

	void bfs(int s) {
		level.assign(V,-1);
		queue<int> q;
		level[s] = 0; q.push(s);
		while (!q.empty()) {
			int v = q.front(); q.pop();
			for(auto &e: G[v]){
				if (e.cap > 0 and level[e.to] < 0) {
					level[e.to] = level[v] + 1;
					q.push(e.to);
				}
			}
		}
	}

	int dfs(int v, int t, int f) {
		if (v == t) return f;
		for (int& i = itr[v]; i < (int) G[v].size(); ++i) {
			edge& e = G[v][i];
			if (e.cap > 0 and level[v] < level[e.to]) {
				int d = dfs(e.to, t, min(f, e.cap));
				if (d > 0) {
					e.cap -= d;
					G[e.to][e.rev].cap += d;
					return d;
				}
			}
		}
		return 0;
	}

	int run(int s, int t) {
		int ret = 0, f;
		while (bfs(s), level[t] >= 0) {
			itr.assign(V,0);
			while ((f = dfs(s, t, inf)) > 0) ret += f;
		}
		return ret;
	}
};
endsnippet

snippet unionfind "UnionFind"
struct UnionFind
{
	// par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである
	vector<int> par;
	// sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる
	vector<int> sizes;

	UnionFind(int n) : par(n), sizes(n, 1) {
		// 最初は全てのデータiがグループiに存在するものとして初期化
		for(int i = 0;i < n;i++) par[i] = i;
	}

	// データxが属する木の根を得る
	int find(int x) {
		if (x == par[x]) return x;
		return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す
	}

	// 2つのデータx, yが属する木をマージする
	void unite(int x, int y) {
		// データの根ノードを得る
		x = find(x);
		y = find(y);
		// 既に同じ木に属しているならマージしない
		if (x == y) return;
		// xの木がyの木より大きくなるようにする
		if (sizes[x] < sizes[y]) swap(x, y);
		// xがyの親になるように連結する
		par[y] = x;
		sizes[x] += sizes[y];
		// sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい
	}

	// 2つのデータx, yが属する木が同じならtrueを返す
	bool same(int x, int y) {
		return find(x) == find(y);
	}

	// データxが含まれる木の大きさを返す
	int size(int x) {
		return sizes[find(x)];
	}
};
endsnippet

snippet isprime "素数判定"
template<class T> inline T isPrime(T x) {
	bool ret = true;
	if (x < 2) {
		ret = false;
	}
	for (LL i = 2; i <= sqrt(x); i++) {
		if (x%i == 0) {
			ret = false;
		}
	}
	return ret;
}
endsnippet

snippet gcd "最大公約数"
LL gcd(LL a,LL b) {
	LL bigger = max(a,b);
	LL smaller = min(a,b);
	if (smaller == 0) return bigger;
	if (smaller < 0) {
		cerr << "smaller of gcd is negative number" << endl;
		return 1;
	}
	if (bigger % smaller != 0) {
		return gcd(smaller,(bigger % smaller));
	}
	return smaller;
}
endsnippet

snippet lcm "最小公倍数"
LL lcm(LL a, LL b) {
	return a*b/gcd(a,b);
}
endsnippet

snippet edge "辺struct"
using edge = struct {LL to; LL cost;};
endsnippet

snippet comb "組み合わせ"
template<typename T> struct comb {
	T n,k;
	LL numerator = 1;   //分子
	LL denominator = 1; //分母
	LL ans = 1;
	comb(T a, T b) : n(a), k(b) {set_nd();}

	// function
	/// 分子分母の設定
	void set_nd() {
		for (T i = 0, j = n; i < k; i++,j--) {
			numerator *= j;
			numerator %= MOD;
		}
		for (T i = 1; i < k + 1; i++) {
			denominator *= i;
			denominator %= MOD;
		}
	}
	/// a^b%pの計算
	LL calcInv(LL a,LL b,LL p) {
		if (b == 0) {
			return 1;
		}
		if (b % 2 == 0) {
			LL d = calcInv(a,b/2,p);
			return (d*d)%p;
		}
		return (a * calcInv(a,b-1,p)) % p;
	}

	LL getans() {
		denominator = calcInv(denominator,MOD-2,MOD);
		return (numerator * denominator) % MOD;
	}

};
endsnippet

snippet form "下がるfor"
for (${1:int} ${2:i} = ${3:0}; $2 >= ${4}; $2--) {
	${0:#:TARGET}
}
endsnippet

snippet primeList "素数リスト作成(エラトステネス)"
VL primeList(LL num) {
	VL ret;
	vector<bool> is_prime(num+1,true);
	for (LL i = 2; i <= (LL)sqrt(num) + 1; i++) {
		if (is_prime[i]) {
			for (int j = i*2; j <= num; j += i) {
				is_prime[j] = false;
			}
		}
	}
	for (int i = 2; i <= num; i++) {
		if (is_prime[i]) {
			ret.push_back(i);
		}
	}
	return ret;
}
endsnippet

snippet isCross "二線分が交差するか判定"
bool isCross(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {
	double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);
	double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);
	double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);
	double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);

	return tc * td < 0 && ta * tb < 0;
}
endsnippet

snippet modint "modをとってくれる整数型"
template <std::uint_fast64_t Modulus> class modint {
	using u64 = std::uint_fast64_t;

	public:
	u64 a;

	constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}
	constexpr u64 &value() noexcept { return a; }
	constexpr const u64 &value() const noexcept { return a; }
	constexpr modint operator+(const modint rhs) const noexcept {
		return modint(*this) += rhs;
	}
	constexpr modint operator-(const modint rhs) const noexcept {
		return modint(*this) -= rhs;
	}
	constexpr modint operator*(const modint rhs) const noexcept {
		return modint(*this) *= rhs;
	}
	constexpr modint operator/(const modint rhs) const noexcept {
		return modint(*this) /= rhs;
	}
	constexpr modint &operator+=(const modint rhs) noexcept {
		a += rhs.a;
		if (a >= Modulus) {
			a -= Modulus;
		}
		return *this;
	}
	constexpr modint &operator-=(const modint rhs) noexcept {
		if (a < rhs.a) {
			a += Modulus;
		}
		a -= rhs.a;
		return *this;
	}
	constexpr modint &operator*=(const modint rhs) noexcept {
		a = a * rhs.a % Modulus;
		return *this;
	}
	constexpr modint &operator/=(modint rhs) noexcept {
		u64 exp = Modulus - 2;
		while (exp) {
			if (exp % 2) {
				*this *= rhs;
			}
			rhs *= rhs;
			exp /= 2;
		}
		return *this;
	}
	friend constexpr ostream &operator<<(ostream& os, modint<MOD> rhs) noexcept {
		os << rhs.a;
		return os;
	}
};
typedef modint<MOD> mint;
typedef vector<mint> VM;
typedef vector<VM> VVM;
endsnippet

